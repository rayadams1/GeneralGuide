Redhat Enterprise linux officially supports 22 languages
The linux command line is provided by a program called shell. Shell is a command interpreter.
Over many UNIX like systems, many shells have been developed. The default shell for Enterprise Linux is the GNU bourne-again shell. Bash is an improved version of one of the most successful shells used on UNIX like systems, the Bourne Shell(sh)

Shell prompt shows that the shell is waiting for a command denoted by $
$ is replaced by # if the user is the root user
bash is the default shell in Mac OS X

Users can access the bash shell through a terminal. It can be done through a physical console or virtual console.
Physical console is the hardware display and keyboard used to interact with the system.
The terminal is an interface that provides a display for output and a keyboard for input to a shell session. Terminal access can be configured through serial ports
The physical console supports multiple virtual consoles which act like separate terminals. Each virtual console supports an independant login session.

Commands entered at the shell prompt have 3 basic parts:
 -> Command to run
 -> Options to adjust the behaviour of the command
 -> Arguements which are typically targets of the command
Options normally start with - or --

=> usermod -L morgan -> lock the password on user morgan's account

=> most commands have --help option
    -> this contains usage statements
	 	-> [] surround optional items
	 	-> anything followed by ... represents an arbitrary-length list of items of that type
	 	-> multiple items separated by | means only one of them can be specified
	 	-> text in <> represents variable data

eg: date [OPTION]... [+FORMAT] -> this indicates that a date can take an optional list of options followed by an optional format string prefixed with a + character

=> exit command terminates the current shell session (or ctrl+d)

The default desktop environment in RedHat enterprise linux is provided by GNOME 3. It provides an integrated desktop for users and a unified development platform on top of a graphical framework provided by the X Window System.

Workspaces are separate desktop screens which have different application windows. These can be used to organize the working environment by grouping open application windows by task. for eg. windows being used to perform a particular system maintenance activity.

Commands are the names of the programs installed on the system
More than 1 command on a single line can be delimited by ;. A ; is a member of a class of characters called metacharacters that has special meanings for bash.

=> superuser can use passwd command to change other user's passwords
=> file command scans the beginning of a file's contents and displays what type it is. for eg. file /etc/passwd
=> head and tail commands display the beginning and ends of a file respectively. for eg. head -n 100 abc.txt, tail -n 100 abc.txt
=> wc command counts lines, words or characters with the options -l, -w and -c respectively. for eg. wc -l abc.txt, wc -w abc.txt, wc -c abc.txt
=> useradd command is used by the superuser, root to create additional users on the system
tab can be used for autocompleting options also after a - or --
=> history command displays a list of all previously executed commands prefixed with a command number
=> ! is a metacharacter used to expand previous commands without having to retype them, !number expands to the command matching the number specified, !string expands to the most recent command that begins with the string specified

ctrl+a jump to beginning of command line
ctrl+e jump to end of command line
ctrl+u clear from the cursor to the beginning of the command line
ctrl+k clear from the cursor to the end of the command line
ctrl+left arrow jump to the beginning of the previous word on the command line
ctrl+right arrow jump to the end of the next word on the command line
ctrl+r search the history list of commands for a pattern

Linux File System Heirarchy
-> single inverted tree of directories.
-> the directory / is the root directory at the top of the FSH, / character is also used as a directory separator in file names.
-> subdirectories of / are used for standardized purposes to organize files by type and purpose.

Following terms are encountered  in describing file system heirarchy:
-> static is content that remains unchanged until explicitly edited or reconfigured.
-> dynamic or variable is content typically modified or appended by active processes.
-> persistent is content, particularly configuration settings, that remain after a reboot.
-> runtime is process or system-specific content or attributes cleared during reboot.

/usr -> installed softwares, shared libraries, include files and static read-only program data.
	-> /usr/bin -> user commands
	-> /usr/sbin -> system administration commands
	-> /usr/local -> locally customized software

/etc -> configuration files specific to this system

/var -> variable data specific to this system that should persist between boots. Files that dynamically change eg. databases, cache directories, log files, printer spooled documents, and website content.

/run -> runtime data for processes started since the last boot. This includes process ID files and lock files. The contents of this directory are recreated upon reboot. This directory consolidates /var/run and /var/lock from older versions of Enterprise Linux.

/home -> home directories where regular users store their personal data and configuration files

/root -> home directory for the administrative superuser, root.

/tmp -> Writable space for temporary files. Files more than 10 days old are deleted from this directory automatically. Another temporary directory /var/tmp in which files that have not been accessed, changed or modified in more than 30 days are deleted automatically.

/boot -> Files needed in order to start the boot process

/dev -> contains special device files which are used by the system to access hardware

bin, sbin, lib, lib64 have been moved from / to /usr/ from older versions of linux by using symlinks(symbolic links)

file names in linux are case sensitive

=> pwd command -> present working directory
=> ls command -> lists all files in that location -> options include -l(long listing), -a(include hidden files), -R(recursive)
=> cd command -> change directories

~ -> users current home directory 

=> touch command -> updates a file's timestamp to the current date and time without otherwise modifying it, otherwise creates an empty file

. -> current directory
.. -> parent directory

these special directories exist in every directory of the system

hidden files are not a security feature. They keep necessary user configuration files from cluttering home directories. Many commands process hidden files only with specific command line options, preventing one user's configuration from being accidentally copied to other directories or users.

To protect a file's contents from improper viewing requires the use of file permissions.

=> cd - command changes directory to the directory where the user was previous to the current directory.
=> cd .. command uses the .. hidden directory to move up one level to the parent directory without needing to know the exact parent directory name.
=> cp -> copy file, cp -r -> copy directory, in any destination, new file names must be unique, if not then the copy command will overwrite the existing file
=> rm -> remove file, rm -r -> remove directory
=> mv -> move file, mv -> move directory
=> mkdir -> creates one or more directories or subdirectories, mkdir -p /par1/par2/dir -> -p option creates missing parent directories for the requested destination, if the parent directories exist in the destination path then -p option is not required.
=> mv dir1 dir2 -> if dir2 exists the result is a move, if not then the result is a rename.

There is no command line undelete feature, nor a trash bin from which to restore

=> rm -i will interactively prompt for each deletion, this is opposite from -f which will forcefully delete without prompting the user
=> rmdir command deletes empty directories

The bash shell has a path name matching capability called globbing.
Globbing is a shell command parsing operation that expands a wildcard pattern into a list of matching path names.

Regex pattern matching in linux
-> * -> matches anything
-> ? -> matches one character
-> [abc...] -> any one character in the enclosed class
-> [!abc...] -> any one character not in the enclosed class
-> [[:alpha:]] -> any alphabetic character 
-> [[:lower:]] -> any lowercase character
-> [[:upper:]] -> any uppercase character
-> [[:alnum:]] -> any alphabetic character or digit
-> [[:digit:]] -> any digit 0-9
-> [[:space:]] -> any one whitespace character

Brace Expansion
echo {Sunday,Monday,Tuesday,Wednesday}.log -> Sunday.log Monday.log Tuesday.log Wednesday.log
echo file{1..3}.txt -> file1.txt file2.txt file3.txt
echo file{a..c}.txt -> filea.txt fileb.txt filec.txt
echo file{a,b}{1,2}.txt -> filea1.txt filea2.txt fileb1.txt fileb2.txt
echo file{a{1,2},b,c}.txt -> filea1.txt filea2.txt fileb.txt filec.txt

Command Substitution
$(command) -> echo The Time is ${date}

Protecting arguements from expansion
\ is an escape character for metacharacters in bash protecting the single following character from special interpretation
use "" to suppress globbing and shell expansion -> echo "*** hostname is ${host} ***" -> *** hostname is desktopx ***
use '' to interpret all text literally -> echo "Will $host evaluate to $(hostname)?" -> Will desktopx evaluate to desktopx?
											   'Will $host evaluate to $(hostname)?' -> Will $host evaluate to $(hostname)?

Sections of the Linux manual
Section Content type
1       User commands(both executable and shell programs)
2       System calls (kernel routines invoked from user space)
3       Library functions (provided by program libraries)
4       Special files (such as device files)
5       File formats (for many configuration files and structures)
6       Games (historical section for amusing programs)
7       Conventions . standards , and miscellaneous (protocols, file systems)
8       System administration and privileged commands (maintenance tasks)
9       Linux kernel API (internal kernel calls)
		
=> man 1 su, man 1 passwd, man -f passwd, man -k zip, man -k boot, man -k ext4 commands
=> passwd -l username -> locks the user's account
=> passwd -u username -> unlocks the user's account

Man pages have a formal format useful as a command reference, but less useful as general documentation. For such documents, the GNU Project developed a different online documenation system known as GNU info. Info documents allow thorough discussion of complex commands and concepts.

=> pinfo tar, info tar, pinfo info, pinfo pinfo, man tar

In addition to man and pinfo, developers may also choose to include documentation in their application's RPM distribution package. When the package is installed, files recognized as documentation are moved to /usr/share/doc/packagename

=> firefox file:///usr/share/doc, less and gedit can also be used

The kernel itself has a significant documentation package. The kernel-doc package is a treasure of kernel, driver, tuning and advanced configuration information. Experienced system administrators regularly research kernel-doc files.

=> less /usr/share/doc/vim-common-*/README.txt
=> less yum-3*/README
=> ls -l bc-*/Examples
=> firefox grub2-tools-*/grub.html
=> yum list *-doc*

use yum to display only those packages that contain "-doc", "-docs", "-documentation" in the package name.

RedHat customer portal (https://access.redhat.com, https://access.redhat.com/help, https://access.redhat.com/site/support/policy/support_process) provides customers with access to everything provided with their subscription through one convenient location.
-> customers can search for solutions, FAQs and articles through KnowledgeBase.
-> access to official product documentation is provided.
-> support tickets can be submitted and managed.
-> subscriptions to RedHat products can be attached and detached from registered systems.
-> software downloads, updates and evaluations can be obtained.

=> redhat-support-tool -> raise a bug to redhat
=> sosreport command, tar -xvJf /var/tmp/sosreport-*.tar.xz command -> diagnostic information, kdump

Processes connect to files using standard connections 0,1,2 for stdin(standard input), stdout(standard output) and stderr(standard error) respectively. Processes use channels 3 and above to connect with other files.

Redirecting stdout suppresses process output from appearing on the terminal. Redirecting only stdout does not suppress stderr error messages from displaying on the terminal.

>file -> redirect stdout to a file
>>file -> redirect stdout to a file, append to current file content
2>file -> redirect stderr to a file
2>/dev/null -> discard stderr error messages by redirecting to a special file /dev/null
&>file -> combine stdout and stderr to 1 file
>>file 2>&1 or &>>file-> combine stdout and stderr, append to current file content

=> diff prevfile currfile >> /tmp/tracking-changes -> appends process output to an existing file
=> find /etc -name passwd 2> /tmp/errors -> redirect errors to a file while viewing normal command outputs
=> find /etc -name passwd > /tmp/output 2> /tmp/errors -> save process output and error messages to separate files
=> find /etc -name passwd > /tmp/output 2> /dev/null -> save process output and ignore and discard error messages

Redirection controls channel output to or from files while piping sends channel output to another process.

=> ls | ws -l > /tmp/countfiles -> count number of lines in an output or listing
=> ls -l | tee /tmp/saved-output -> the tee command displays or redirects the intermediate result normally suppressed due to piping.
=> tty -> ?

The key design principle of Linux is that information is stored in text based files. Text files include both flat files with rows of similar information such as configuration files in /etc and Extensible Markup Language(XML) files which define data structure through text tags seen in application configuration files throughout both /etc and /usr. The advantage of text files is that they can be shared and moved between systems without conversion. They can also be viewed and edited using any simple text editor.

Vim is an improved version of the vi text editor distributed with Linux and Unix Systems.
i key -> insert mode
esc key -> command mode
v key -> single line visual mode
  -> V -> multi line 
  -> ctrl+v -> block selection
  -> v, V, ctrl+v -> exit visual mode
: key -> begins extended command mode for tasks like writing the file to save it, and quitting the vim editor
:w -> write(save) the file and remain in command mode for more editing
:wq -> write the file and quit vim
:q! -> quit vim, but discard all file changes since the last write

In vim copy and paste is called yank and put using command characters y and p

refer http ://www.vim.org/

=> vimtutor command -> learn more about vim
=> gedit abc.txt &

Every process on the system runs as a particular user. Every file is owned by a particular user. Access to files and directories are restricted by user. The user associated with a running process determines the files and directories accessible to that process.

=> id command -> used to show information about the current logged-in user. Basic information about another user can also be requested by passing in the username of that user as the first arguement to the id command.

=> ps command -> to show process information in the current shell by default. Add -a to view all processes with a terminal. To view user associated with the processes include -u .

Internally the operating system tracks users by UID number. The mapping of names to UIDs are defined in databases of account information. 
By default systems use a flat file, the /etc/passwd file to store information about local users.

Format of /etc/passwd file -> username:password:UID:GID:GECOS:/home/dir:shell
	->passwords are stored in a separate file /etc/shadow
	->GID -> primary group id
	->GECOS -> includes user's real name
Like users, groups have a name and a number. Local groups are defined in /etc/group

Every user has exactly 1 primary group. Normally the primary group owns new files created by the user. Normally the primary group of a newly created user is a newly created group with the same name as the user. The user is the only member of this User Private Group(UPG)
Users may be a member of 0 or more supplementary groups.

Format of /etc/group -> groupname:password:GID:list of users in this group
Supplementary group membership is used to help ensure that users have access permissions to files and other resources on the system.

Most operating systems have some sort of a superuser, a user that has all power over the system. This user in RHEL is the root user. This user has the power to override normal privileges on the file system, and is used to manage and administer the system. In order to perform tasks such as installing or removing software and to manage system files and directories, a user must escalate privileges to the root user.
Only root user is allowed to manage fixed hard drives whereas anyone can manage USBs or removable devices.
The root account in Linux is roughly equivalent to the local administrator account on windows. In Linux most system administrators log into an unprivileged user account and use various tools to temporarily gain root privileges.

=> su, sudo, PolicyKit -> temporarily gain superuser privileges
=> su username command -> Starts a non login shell, starts a shell as a user with the current environment settings
=> su - username -> starts a login shell, clean login as a user
=> su -> switch to root user
=> sudo command -> allows a user to be permitted to run a command as root, or as another user, based on settings in the /etc/sudoers file. Unlike other tools such as su, sudo requires users to enter their own password for authentication, not the password of the account they are trying to access. This allows the administrator to hand out fine grained permissions to users to delegate system administration tasks, without having to hand out the root password. All commands executed using sudo are logged by default to /var/log/secure.
All members of group wheel can use sudo to run commands as any user, including root.
pkexec and polkit

=> useradd username command sets reasonable defaults for all fields in /etc/passwd when run without options. The command does not set any valid password by default, the user cannot login until a password is set.
=> usermod command -> modify an existing user, some defaults like the range of valid UIDs and password aging rules are read from the /etc/login.defs. Values in these files are only used when creating new users. A change to this file will have any effect on any existing users.

=> userdel username -> removes the user from /etc/passwd, but leaves the home directory intact by default, -r option removes the user and the user's home directory, without -r option, the system will have files that are owned by an unassigned user ID number. 
the useradd command assigns new users the first free UID number available in the range starting from UID 1000 or above(unless -u option is provided)

when a user is deleted his UID can be assigned to another user making the new user the owner of the files the old user created.
find / -nouser -o -nogroup 2> /dev/null => find all unowned files and directories  

id => displays UID and group membership.
id username => displays user information including UID and group membership.
passwd username => can be either used to set the user's initial password or change that user's password

The root user can set a password to any value. A regular user must choose a password which is atleast 8 characters long and is not a dictionary word, the username or the previous password.

UID 0 is always assigned to the superuser account, the root.
UID 1-200 is a range of system users assigned statically to system processes by RedHat
UID 201-999 is a range of system users used by system processes that do not own files on the file system. They are typically assigned dynamically from the available pool when the software that needs them is installed. Programs run as these unprivileged system users in order to limit their access to just the resources they need to function.
UID 1000+ is the range available to assign to regular users.

default ranges used by useradd and groupadd can be changes in the /etc/login.defs file

A group must exist before a user can be added to that group.
groupadd groupname => uses the next available GID from the range specified in the /etc/login.defs file. -g option is used to specify a specific GID.

groupmod => used to change a groupname to a GID mapping. -n option is used to specify a new name. -g option is used to specify a new GID
(groupmod -n javaapp appusers, groupmod -g 6000 ateam)
groupdel => removes a group

A group may not be removed if it is the primary group of any existing user. As with userdel, check all file systems to ensure that no files remain owned by the group.

usermod -g student student => change a user's primary group
usermod -aG groupname username => add a user to a supplementary group 
-a option makes usermod function in append mode. Without it the user will be removed from all other supplementary groups.

/etc/shadow file were more secure as they prevented dictionary attacks on encrypted passwords kept in the world-readable /etc/passwd file. This new file also allowed password aging and expiration features to be implemented.

There are 3 pieces of information stored in a modern password hash
1. The hashing algorithm. 1 indicates an MD5 hash. 6 indicates SHA-512 hash. 5 indicates SHA-256 hash.
2. The salt used to encrypt the hash. This is originally chosen at random. The use of a salt prevents 2 users with the same password from having identical entries in the /etc/shadow file.
3. The encrypted hash

=> authconfig --passalgo md5/sha256/sha512 -> change default algorithm used for password hashes

Format of /etc/shadow 
name:password:lastchange:minage:maxage:warning:inactive:expire:blank
the password field which starts with ! means that the password is locked
the date of the last password change, represented as the number of days since 1970.01.01
minimum number of days before a password may be changed where 0 means no age requirement
maximum number of days before a password must be changed
the warning period that a password is about to expire. represented in days. 0 means no warning given 
the number of days an account remains active after a password has expired. A user may still log into the system and change the password during this period. After the specified number of days, the account is locked, becoming inactive.
the account expiration date, represented as the number of days since 1970.01.01
this blank field is reserved for future use

=> chage command -> to change password aging policy
=> chage -d 0 username -> will force a password update on next login 
=> chage -l username -> list a username's current settings
=> chage -E YYYY-MM-DD -> will expire an account on a specific day

=> date -d "+45 days" -> calculates a date 45 days in future

=> usermod -L -e 1 username -> When a user has left the company, the administrator may lock and expire an account with a single usermod command. 

sometimes a user needs an account with a password to authenticate to a system, but does not need an interactive shell on the system. For eg. a mail server may require an account to store mail and a password for the user to authenticate with a mail client used to retrieve mail. That user does not need to log directly into the system. The solution to this problem is to set the user's login shell to /sbin/nologin. If the user tries to login to the system directly, the nologin shell will simply close the connection.

use of the nologin shell prevents interactive use of the system, but does not prevent all access. A user may still be able to authenticate and upload or retireve files through applications such as web applications, file transfer programs, or mail readers.

Access to files by users are controlled by file permissions. The file is owned by a user, normally the one who created the file. The file is also owned by a single group, usually the primary group of the user who created the file, but this can be changed. Default permissions can be set for the owning user, the owning group, and for all other users on the system that are not the user or a member of the owning group.

The most specific permissions apply. So user permissions override group permissions, which override other permissions.

r->read,w->write,x->execute . If a user has only exec access on a directory, they cannot list the names of the files in the directory, but if they already know the name of a file which they have permission to read, then they can access the contents of that file by explicitly specifying the file name.

A file may be removed by anyone who has write permissions to the directory in which the file resides, regardless of the ownership or permissions on the file itself. This can be overridden with a special permission.

write permission on directories include the ability to delete files and subdirectories.

rwxrwxr-x  ricky ricardo dir
	rw-rw-r-- lucy lucy file1
	rw-r--rw- lucy ricardo file2
	rw-rw-r-- ricky ricardo file3
	rw-r----- ricky ricardo file4

	ricky is a member of the group ricardo, and that group has read-only permissions on file2. Even though other has write permissions, group permissions take precedence
	ricky has write permissions on the directory containing all files. He can delete any file in the directory 
	ethel can change the contents of file2, since she is not a member of the ricardo group, other permissions apply for her
	lucy can change the contents of file3. Since she is a member of the ricardo group. That group has both read and write permissions on file3

=> chmod -> command use to change permissions from the command line short for 'change mode' -> permissions are also called the mode of the file. The instruction can be given symbolically or numerically.
u, g, o, a stand for user, group, other, all
+, -, = mean add permissions to a set, remove permissions from a set, set permissions exactly to a set
r, w, x mean read write and executable
r=4, w=2, x=1

=> chmod -R -> recurseively sets permissions on an entire directory tree
=> chmod -R g+rwX demodir -> X permission instead of x permission indicates that execute permissions should only be set on directories and not regular files

execute is the traversal permission in a directory. It allows you to access files and folders within a directory

=> chown foofile student -> to change file ownership for foofile to student
-R -> recurseively change the ownership of an entire directory tree

=> chown visitor:guest dir -> change both the owner and the group of a directory at the same time.
Only root can change ownership of a file. Group ownership can be set by root or the file's owner.
root can grant ownership to any group. non-root users can grant ownerships only to groups they belong to.
=> chgrp -> chown -R

setuid or setgid permission on an executable file means that the command will run as the user(group) of the file and not the user that ran the command.
setgid on a directory means that files created in the directory will inherit the group affiliation from the directory, rather than inheriting it from the creating user. This is commonly used on group collaborative directories to automatically change a file from the default private group to the shared group

u+s -> file executes as the user that owns the file, not the user than ran the file, no effect on directories
g+s -> file executes as the group that owns the file, files newly created in the directory have their group owner set to match the group owner of the directory
eg. ls -l /usr/bin/passwd
o+t -> no effect on files, users with write on the directory can only remove files that they own, they cannot remove or force saves to files owned by other users
eg. ls -ld /tmp

setuid -> u+s -> 4
setgid -> g+s -> 2
sticky -> o+t -> 1

=> chmod 2770 directory -> sets gid bit, and read/write and execute for user and group on the directory
=> chmod g+s directory -> add the setgid bit on directory

The default permissions for files are set by processes that create them. for eg. text editor creates files so they are only readable and writable and not executable by everyone. The same goes for shell redirection. Binary executables are created executable by the compilers that create them. 

=> umask command without arguements will display the current value of the shell's umask.
Every process on the system has a umask, which is an octal bitmask that is used to clear the permissions of new files and directories that are created by a process. A umask of 0002 clears the write bit for other users. A umask of 077 clears all the group and other permissions of newly created files.

The system default umask values for bash shell users are defined in the /etc/profile and /etc/bashrc files. Users can override the system defaults in their .bash_profile and .bashrc files
=> umask 027 -> sets the umask to 027
All preceding missing numbers will be set to 0

A process is a running instance of a launched, executable program. A process consists of :
	-> an address space of allocated memory
	-> security properties including ownership credentials and privileges
	-> 1 or more execution threads of program code
	-> the process state

The environment of a process includes:
	-> local and global variables
	-> a current scheduling context
	-> allocated system resources, such as file descriptors and network ports

An existing parent process duplicates its own address space(fork) to create a new child process structure. Every new process is assigned a unique process ID (PID) for tracking and security. The PID and the parent process ID (PPID) are elements of the new process environment. Any process may create a child process. All processes are descendants of the first system process, which is systemd 

=> ps command is used for listing current processes :
 -> UID -> determines process privileges
 -> PID -> process identification id
 -> cpu and real time already expended
 -> how much memory the process has allocated in various locations
 -> location of process stdout, known as controlling terminal
 -> the current process state

 => ps aux
 => ps lax
 => ps -ef

 ps with no options selects all processes with the same effective user id as current user and associated with the same terminal where ps was invoked.
 -> processes in brackets are scheduled kernel threads
 -> zombies show up in a ps listing as exiting or defunct(zombie is a state of a process wherein it gives up all its resources except the PID)

 => top command -> repetitive update process display
  ps can display in tree format to view parent/child relationships

 Job control is a command shell feature allowing a single shell instance to run and manage multiple commands. Without job control, a parent shell forks a child process to run a command sleeping until the child process exits. When the shell prompt redisplays, the parent shell has returned. With job control, commands can be selectively suspended, resumed and run asynchronously, allowing the shell to return for additional commands while child processes run. 
 
 A foreground process is a command running in a terminal window. The terminal's device id(tty) is the process's controlling terminal. Foreground processes receive keyboard generated input and signals and are allowed to read from or write to the terminal(stdin or stdout).

 A process session is created when a terminal or console first opens(eg. at login or by invoking a new terminal instance). All processes(first command shell, its children and pipelines ) initiated from that terminal share the same session id. Within a session, only 1 process can be in the foreground at a time.

 A background process is started without a controlling terminal because it has no need for terminal interaction. In a ps listing, such processes (eg. service daemons and kernel process threads) display a ? in the tty column. Background processes which (improperly)attempt to read from or write to the terminal may be suspended.

    

































































































































