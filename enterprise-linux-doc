Redhat Enterprise linux officially supports 22 languages
The linux command line is provided by a program called shell. Shell is a command interpreter.
Over many UNIX like systems, many shells have been developed. The default shell for Enterprise Linux is the GNU bourne-again shell. Bash is an improved version of one of the most successful shells used on UNIX like systems, the Bourne Shell(sh)

Shell prompt shows that the shell is waiting for a command denoted by $
$ is replaced by # if the user is the root user
bash is the default shell in Mac OS X

Users can access the bash shell through a terminal. It can be done through a physical console or virtual console.
Physical console is the hardware display and keyboard used to interact with the system.
The terminal is an interface that provides a display for output and a keyboard for input to a shell session. Terminal access can be configured through serial ports
The physical console supports multiple virtual consoles which act like separate terminals. Each virtual console supports an independant login session.

Commands entered at the shell prompt have 3 basic parts:
 -> Command to run
 -> Options to adjust the behaviour of the command
 -> Arguements which are typically targets of the command
Options normally start with - or --

=> usermod -L morgan -> lock the password on user morgan's account

=> most commands have --help option
    -> this contains usage statements
	 	-> [] surround optional items
	 	-> anything followed by ... represents an arbitrary-length list of items of that type
	 	-> multiple items separated by | means only one of them can be specified
	 	-> text in <> represents variable data

eg: date [OPTION]... [+FORMAT] -> this indicates that a date can take an optional list of options followed by an optional format string prefixed with a + character

=> exit command terminates the current shell session (or ctrl+d)

The default desktop environment in RedHat enterprise linux is provided by GNOME 3. It provides an integrated desktop for users and a unified development platform on top of a graphical framework provided by the X Window System.

Workspaces are separate desktop screens which have different application windows. These can be used to organize the working environment by grouping open application windows by task. for eg. windows being used to perform a particular system maintenance activity.

Commands are the names of the programs installed on the system
More than 1 command on a single line can be delimited by ;. A ; is a member of a class of characters called metacharacters that has special meanings for bash.

=> superuser can use passwd command to change other user's passwords
=> file command scans the beginning of a file's contents and displays what type it is. for eg. file /etc/passwd
=> head and tail commands display the beginning and ends of a file respectively. for eg. head -n 100 abc.txt, tail -n 100 abc.txt
=> wc command counts lines, words or characters with the options -l, -w and -c respectively. for eg. wc -l abc.txt, wc -w abc.txt, wc -c abc.txt
=> useradd command is used by the superuser, root to create additional users on the system
tab can be used for autocompleting options also after a - or --
=> history command displays a list of all previously executed commands prefixed with a command number
=> ! is a metacharacter used to expand previous commands without having to retype them, !number expands to the command matching the number specified, !string expands to the most recent command that begins with the string specified

ctrl+a jump to beginning of command line
ctrl+e jump to end of command line
ctrl+u clear from the cursor to the beginning of the command line
ctrl+k clear from the cursor to the end of the command line
ctrl+left arrow jump to the beginning of the previous word on the command line
ctrl+right arrow jump to the end of the next word on the command line
ctrl+r search the history list of commands for a pattern

Linux File System Heirarchy
-> single inverted tree of directories.
-> the directory / is the root directory at the top of the FSH, / character is also used as a directory separator in file names.
-> subdirectories of / are used for standardized purposes to organize files by type and purpose.

Following terms are encountered  in describing file system heirarchy:
-> static is content that remains unchanged until explicitly edited or reconfigured.
-> dynamic or variable is content typically modified or appended by active processes.
-> persistent is content, particularly configuration settings, that remain after a reboot.
-> runtime is process or system-specific content or attributes cleared during reboot.

/usr -> installed softwares, shared libraries, include files and static read-only program data.
	-> /usr/bin -> user commands
	-> /usr/sbin -> system administration commands
	-> /usr/local -> locally customized software

/etc -> configuration files specific to this system

/var -> variable data specific to this system that should persist between boots. Files that dynamically change eg. databases, cache directories, log files, printer spooled documents, and website content.

/run -> runtime data for processes started since the last boot. This includes process ID files and lock files. The contents of this directory are recreated upon reboot. This directory consolidates /var/run and /var/lock from older versions of Enterprise Linux.

/home -> home directories where regular users store their personal data and configuration files

/root -> home directory for the administrative superuser, root.

/tmp -> Writable space for temporary files. Files more than 10 days old are deleted from this directory automatically. Another temporary directory /var/tmp in which files that have not been accessed, changed or modified in more than 30 days are deleted automatically.

/boot -> Files needed in order to start the boot process

/dev -> contains special device files which are used by the system to access hardware

bin, sbin, lib, lib64 have been moved from / to /usr/ from older versions of linux by using symlinks(symbolic links)

file names in linux are case sensitive

=> pwd command -> present working directory
=> ls command -> lists all files in that location -> options include -l(long listing), -a(include hidden files), -R(recursive)
=> cd command -> change directories

~ -> users current home directory 

=> touch command -> updates a file's timestamp to the current date and time without otherwise modifying it, otherwise creates an empty file

. -> current directory
.. -> parent directory

these special directories exist in every directory of the system

hidden files are not a security feature. They keep necessary user configuration files from cluttering home directories. Many commands process hidden files only with specific command line options, preventing one user's configuration from being accidentally copied to other directories or users.

To protect a file's contents from improper viewing requires the use of file permissions.

=> cd - command changes directory to the directory where the user was previous to the current directory.
=> cd .. command uses the .. hidden directory to move up one level to the parent directory without needing to know the exact parent directory name.
=> cp -> copy file, cp -r -> copy directory, in any destination, new file names must be unique, if not then the copy command will overwrite the existing file
=> rm -> remove file, rm -r -> remove directory
=> mv -> move file, mv -> move directory
=> mkdir -> creates one or more directories or subdirectories, mkdir -p /par1/par2/dir -> -p option creates missing parent directories for the requested destination, if the parent directories exist in the destination path then -p option is not required.
=> mv dir1 dir2 -> if dir2 exists the result is a move, if not then the result is a rename.

There is no command line undelete feature, nor a trash bin from which to restore

=> rm -i will interactively prompt for each deletion, this is opposite from -f which will forcefully delete without prompting the user
=> rmdir command deletes empty directories

The bash shell has a path name matching capability called globbing.
Globbing is a shell command parsing operation that expands a wildcard pattern into a list of matching path names.

Regex pattern matching in linux
-> * -> matches anything
-> ? -> matches one character
-> [abc...] -> any one character in the enclosed class
-> [!abc...] -> any one character not in the enclosed class
-> [[:alpha:]] -> any alphabetic character 
-> [[:lower:]] -> any lowercase character
-> [[:upper:]] -> any uppercase character
-> [[:alnum:]] -> any alphabetic character or digit
-> [[:digit:]] -> any digit 0-9
-> [[:space:]] -> any one whitespace character

Brace Expansion
echo {Sunday,Monday,Tuesday,Wednesday}.log -> Sunday.log Monday.log Tuesday.log Wednesday.log
echo file{1..3}.txt -> file1.txt file2.txt file3.txt
echo file{a..c}.txt -> filea.txt fileb.txt filec.txt
echo file{a,b}{1,2}.txt -> filea1.txt filea2.txt fileb1.txt fileb2.txt
echo file{a{1,2},b,c}.txt -> filea1.txt filea2.txt fileb.txt filec.txt

Command Substitution
$(command) -> echo The Time is ${date}

Protecting arguements from expansion
\ is an escape character for metacharacters in bash protecting the single following character from special interpretation
use "" to suppress globbing and shell expansion -> echo "*** hostname is ${host} ***" -> *** hostname is desktopx ***
use '' to interpret all text literally -> echo "Will $host evaluate to $(hostname)?" -> Will desktopx evaluate to desktopx?
											   'Will $host evaluate to $(hostname)?' -> Will $host evaluate to $(hostname)?

Sections of the Linux manual
Section Content type
1       User commands(both executable and shell programs)
2       System calls (kernel routines invoked from user space)
3       Library functions (provided by program libraries)
4       Special files (such as device files)
5       File formats (for many configuration files and structures)
6       Games (historical section for amusing programs)
7       Conventions . standards , and miscellaneous (protocols, file systems)
8       System administration and privileged commands (maintenance tasks)
9       Linux kernel API (internal kernel calls)
		
=> man 1 su, man 1 passwd, man -f passwd, man -k zip, man -k boot, man -k ext4 commands
=> passwd -l username -> locks the user's account
=> passwd -u username -> unlocks the user's account

Man pages have a formal format useful as a command reference, but less useful as general documentation. For such documents, the GNU Project developed a different online documenation system known as GNU info. Info documents allow thorough discussion of complex commands and concepts.

=> pinfo tar, info tar, pinfo info, pinfo pinfo, man tar

In addition to man and pinfo, developers may also choose to include documentation in their application's RPM distribution package. When the package is installed, files recognized as documentation are moved to /usr/share/doc/packagename

=> firefox file:///usr/share/doc, less and gedit can also be used

The kernel itself has a significant documentation package. The kernel-doc package is a treasure of kernel, driver, tuning and advanced configuration information. Experienced system administrators regularly research kernel-doc files.

=> less /usr/share/doc/vim-common-*/README.txt
=> less yum-3*/README
=> ls -l bc-*/Examples
=> firefox grub2-tools-*/grub.html
=> yum list *-doc*

use yum to display only those packages that contain "-doc", "-docs", "-documentation" in the package name.

RedHat customer portal (https://access.redhat.com, https://access.redhat.com/help, https://access.redhat.com/site/support/policy/support_process) provides customers with access to everything provided with their subscription through one convenient location.
-> customers can search for solutions, FAQs and articles through KnowledgeBase.
-> access to official product documentation is provided.
-> support tickets can be submitted and managed.
-> subscriptions to RedHat products can be attached and detached from registered systems.
-> software downloads, updates and evaluations can be obtained.

=> redhat-support-tool -> raise a bug to redhat
=> sosreport command, tar -xvJf /var/tmp/sosreport-*.tar.xz command -> diagnostic information, kdump

Processes connect to files using standard connections 0,1,2 for stdin(standard input), stdout(standard output) and stderr(standard error) respectively. Processes use channels 3 and above to connect with other files.

Redirecting stdout suppresses process output from appearing on the terminal. Redirecting only stdout does not suppress stderr error messages from displaying on the terminal.

>file -> redirect stdout to a file
>>file -> redirect stdout to a file, append to current file content
2>file -> redirect stderr to a file
2>/dev/null -> discard stderr error messages by redirecting to a special file /dev/null
&>file -> combine stdout and stderr to 1 file
>>file 2>&1 or &>>file-> combine stdout and stderr, append to current file content

=> diff prevfile currfile >> /tmp/tracking-changes -> appends process output to an existing file
=> find /etc -name passwd 2> /tmp/errors -> redirect errors to a file while viewing normal command outputs
=> find /etc -name passwd > /tmp/output 2> /tmp/errors -> save process output and error messages to separate files
=> find /etc -name passwd > /tmp/output 2> /dev/null -> save process output and ignore and discard error messages

Redirection controls channel output to or from files while piping sends channel output to another process.

=> ls | ws -l > /tmp/countfiles -> count number of lines in an output or listing
=> ls -l | tee /tmp/saved-output -> the tee command displays or redirects the intermediate result normally suppressed due to piping.
=> tty -> ?

The key design principle of Linux is that information is stored in text based files. Text files include both flat files with rows of similar information such as configuration files in /etc and Extensible Markup Language(XML) files which define data structure through text tags seen in application configuration files throughout both /etc and /usr. The advantage of text files is that they can be shared and moved between systems without conversion. They can also be viewed and edited using any simple text editor.

Vim is an improved version of the vi text editor distributed with Linux and Unix Systems.
i key -> insert mode
esc key -> command mode
v key -> single line visual mode
  -> V -> multi line 
  -> ctrl+v -> block selection
  -> v, V, ctrl+v -> exit visual mode
: key -> begins extended command mode for tasks like writing the file to save it, and quitting the vim editor
:w -> write(save) the file and remain in command mode for more editing
:wq -> write the file and quit vim
:q! -> quit vim, but discard all file changes since the last write

In vim copy and paste is called yank and put using command characters y and p

refer http ://www.vim.org/

=> vimtutor command -> learn more about vim
=> gedit abc.txt &

Every process on the system runs as a particular user. Every file is owned by a particular user. Access to files and directories are restricted by user. The user associated with a running process determines the files and directories accessible to that process.

=> id command -> used to show information about the current logged-in user. Basic information about another user can also be requested by passing in the username of that user as the first arguement to the id command.

=> ps command -> to show process information in the current shell by default. Add -a to view all processes with a terminal. To view user associated with the processes include -u .

Internally the operating system tracks users by UID number. The mapping of names to UIDs are defined in databases of account information. 
By default systems use a flat file, the /etc/passwd file to store information about local users.

Format of /etc/passwd file -> username:password:UID:GID:GECOS:/home/dir:shell
	->passwords are stored in a separate file /etc/shadow
	->GID -> primary group id
	->GECOS -> includes user's real name
Like users, groups have a name and a number. Local groups are defined in /etc/group

Every user has exactly 1 primary group. Normally the primary group owns new files created by the user. Normally the primary group of a newly created user is a newly created group with the same name as the user. The user is the only member of this User Private Group(UPG)
Users may be a member of 0 or more supplementary groups.

Format of /etc/group -> groupname:password:GID:list of users in this group
Supplementary group membership is used to help ensure that users have access permissions to files and other resources on the system.

Most operating systems have some sort of a superuser, a user that has all power over the system. This user in RHEL is the root user. This user has the power to override normal privileges on the file system, and is used to manage and administer the system. In order to perform tasks such as installing or removing software and to manage system files and directories, a user must escalate privileges to the root user.
Only root user is allowed to manage fixed hard drives whereas anyone can manage USBs or removable devices.
The root account in Linux is roughly equivalent to the local administrator account on windows. In Linux most system administrators log into an unprivileged user account and use various tools to temporarily gain root privileges.

=> su, sudo, PolicyKit -> temporarily gain superuser privileges
=> su username command -> Starts a non login shell, starts a shell as a user with the current environment settings
=> su - username -> starts a login shell, clean login as a user
=> su -> switch to root user
=> sudo command -> allows a user to be permitted to run a command as root, or as another user, based on settings in the /etc/sudoers file. Unlike other tools such as su, sudo requires users to enter their own password for authentication, not the password of the account they are trying to access. This allows the administrator to hand out fine grained permissions to users to delegate system administration tasks, without having to hand out the root password. All commands executed using sudo are logged by default to /var/log/secure.
All members of group wheel can use sudo to run commands as any user, including root.
pkexec and polkit

=> useradd username command sets reasonable defaults for all fields in /etc/passwd when run without options. The command does not set any valid password by default, the user cannot login until a password is set.
=> usermod command -> modify an existing user, some defaults like the range of valid UIDs and password aging rules are read from the /etc/login.defs. Values in these files are only used when creating new users. A change to this file will have any effect on any existing users.

=> userdel username -> removes the user from /etc/passwd, but leaves the home directory intact by default, -r option removes the user and the user's home directory, without -r option, the system will have files that are owned by an unassigned user ID number. 
the useradd command assigns new users the first free UID number available in the range starting from UID 1000 or above(unless -u option is provided)

when a user is deleted his UID can be assigned to another user making the new user the owner of the files the old user created.
find / -nouser -o -nogroup 2> /dev/null => find all unowned files and directories  

id => displays UID and group membership.
id username => displays user information including UID and group membership.
passwd username => can be either used to set the user's initial password or change that user's password

The root user can set a password to any value. A regular user must choose a password which is atleast 8 characters long and is not a dictionary word, the username or the previous password.

UID 0 is always assigned to the superuser account, the root.
UID 1-200 is a range of system users assigned statically to system processes by RedHat
UID 201-999 is a range of system users used by system processes that do not own files on the file system. They are typically assigned dynamically from the available pool when the software that needs them is installed. Programs run as these unprivileged system users in order to limit their access to just the resources they need to function.
UID 1000+ is the range available to assign to regular users.

default ranges used by useradd and groupadd can be changes in the /etc/login.defs file

A group must exist before a user can be added to that group.
groupadd groupname => uses the next available GID from the range specified in the /etc/login.defs file. -g option is used to specify a specific GID.

groupmod => used to change a groupname to a GID mapping. -n option is used to specify a new name. -g option is used to specify a new GID
(groupmod -n javaapp appusers, groupmod -g 6000 ateam)
groupdel => removes a group

A group may not be removed if it is the primary group of any existing user. As with userdel, check all file systems to ensure that no files remain owned by the group.

usermod -g student student => change a user's primary group
usermod -aG groupname username => add a user to a supplementary group 
-a option makes usermod function in append mode. Without it the user will be removed from all other supplementary groups.

/etc/shadow file were more secure as they prevented dictionary attacks on encrypted passwords kept in the world-readable /etc/passwd file. This new file also allowed password aging and expiration features to be implemented.

There are 3 pieces of information stored in a modern password hash
1. The hashing algorithm. 1 indicates an MD5 hash. 6 indicates SHA-512 hash. 5 indicates SHA-256 hash.
2. The salt used to encrypt the hash. This is originally chosen at random. The use of a salt prevents 2 users with the same password from having identical entries in the /etc/shadow file.
3. The encrypted hash

=> authconfig --passalgo md5/sha256/sha512 -> change default algorithm used for password hashes

Format of /etc/shadow 
name:password:lastchange:minage:maxage:warning:inactive:expire:blank
the password field which starts with ! means that the password is locked
the date of the last password change, represented as the number of days since 1970.01.01
minimum number of days before a password may be changed where 0 means no age requirement
maximum number of days before a password must be changed
the warning period that a password is about to expire. represented in days. 0 means no warning given 
the number of days an account remains active after a password has expired. A user may still log into the system and change the password during this period. After the specified number of days, the account is locked, becoming inactive.
the account expiration date, represented as the number of days since 1970.01.01
this blank field is reserved for future use

=> chage command -> to change password aging policy
=> chage -d 0 username -> will force a password update on next login 
=> chage -l username -> list a username's current settings
=> chage -E YYYY-MM-DD -> will expire an account on a specific day

=> date -d "+45 days" -> calculates a date 45 days in future

=> usermod -L -e 1 username -> When a user has left the company, the administrator may lock and expire an account with a single usermod command. 

sometimes a user needs an account with a password to authenticate to a system, but does not need an interactive shell on the system. For eg. a mail server may require an account to store mail and a password for the user to authenticate with a mail client used to retrieve mail. That user does not need to log directly into the system. The solution to this problem is to set the user's login shell to /sbin/nologin. If the user tries to login to the system directly, the nologin shell will simply close the connection.

use of the nologin shell prevents interactive use of the system, but does not prevent all access. A user may still be able to authenticate and upload or retireve files through applications such as web applications, file transfer programs, or mail readers.

Access to files by users are controlled by file permissions. The file is owned by a user, normally the one who created the file. The file is also owned by a single group, usually the primary group of the user who created the file, but this can be changed. Default permissions can be set for the owning user, the owning group, and for all other users on the system that are not the user or a member of the owning group.

The most specific permissions apply. So user permissions override group permissions, which override other permissions.

r->read,w->write,x->execute . If a user has only exec access on a directory, they cannot list the names of the files in the directory, but if they already know the name of a file which they have permission to read, then they can access the contents of that file by explicitly specifying the file name.

A file may be removed by anyone who has write permissions to the directory in which the file resides, regardless of the ownership or permissions on the file itself. This can be overridden with a special permission.

write permission on directories include the ability to delete files and subdirectories.

rwxrwxr-x  ricky ricardo dir
	rw-rw-r-- lucy lucy file1
	rw-r--rw- lucy ricardo file2
	rw-rw-r-- ricky ricardo file3
	rw-r----- ricky ricardo file4

	ricky is a member of the group ricardo, and that group has read-only permissions on file2. Even though other has write permissions, group permissions take precedence
	ricky has write permissions on the directory containing all files. He can delete any file in the directory 
	ethel can change the contents of file2, since she is not a member of the ricardo group, other permissions apply for her
	lucy can change the contents of file3. Since she is a member of the ricardo group. That group has both read and write permissions on file3

=> chmod -> command use to change permissions from the command line short for 'change mode' -> permissions are also called the mode of the file. The instruction can be given symbolically or numerically.
u, g, o, a stand for user, group, other, all
+, -, = mean add permissions to a set, remove permissions from a set, set permissions exactly to a set
r, w, x mean read write and executable
r=4, w=2, x=1

=> chmod -R -> recurseively sets permissions on an entire directory tree
=> chmod -R g+rwX demodir -> X permission instead of x permission indicates that execute permissions should only be set on directories and not regular files

execute is the traversal permission in a directory. It allows you to access files and folders within a directory

=> chown foofile student -> to change file ownership for foofile to student
-R -> recurseively change the ownership of an entire directory tree

=> chown visitor:guest dir -> change both the owner and the group of a directory at the same time.
Only root can change ownership of a file. Group ownership can be set by root or the file's owner.
root can grant ownership to any group. non-root users can grant ownerships only to groups they belong to.
=> chgrp -> chown -R

setuid or setgid permission on an executable file means that the command will run as the user(group) of the file and not the user that ran the command.
setgid on a directory means that files created in the directory will inherit the group affiliation from the directory, rather than inheriting it from the creating user. This is commonly used on group collaborative directories to automatically change a file from the default private group to the shared group

u+s -> file executes as the user that owns the file, not the user than ran the file, no effect on directories
g+s -> file executes as the group that owns the file, files newly created in the directory have their group owner set to match the group owner of the directory
eg. ls -l /usr/bin/passwd
o+t -> no effect on files, users with write on the directory can only remove files that they own, they cannot remove or force saves to files owned by other users
eg. ls -ld /tmp

setuid -> u+s -> 4
setgid -> g+s -> 2
sticky -> o+t -> 1

=> chmod 2770 directory -> sets gid bit, and read/write and execute for user and group on the directory
=> chmod g+s directory -> add the setgid bit on directory

The default permissions for files are set by processes that create them. for eg. text editor creates files so they are only readable and writable and not executable by everyone. The same goes for shell redirection. Binary executables are created executable by the compilers that create them. 

=> umask command without arguements will display the current value of the shell's umask.
Every process on the system has a umask, which is an octal bitmask that is used to clear the permissions of new files and directories that are created by a process. A umask of 0002 clears the write bit for other users. A umask of 077 clears all the group and other permissions of newly created files.

The system default umask values for bash shell users are defined in the /etc/profile and /etc/bashrc files. Users can override the system defaults in their .bash_profile and .bashrc files
=> umask 027 -> sets the umask to 027
All preceding missing numbers will be set to 0

A process is a running instance of a launched, executable program. A process consists of :
	-> an address space of allocated memory
	-> security properties including ownership credentials and privileges
	-> 1 or more execution threads of program code
	-> the process state

The environment of a process includes:
	-> local and global variables
	-> a current scheduling context
	-> allocated system resources, such as file descriptors and network ports

An existing parent process duplicates its own address space(fork) to create a new child process structure. Every new process is assigned a unique process ID (PID) for tracking and security. The PID and the parent process ID (PPID) are elements of the new process environment. Any process may create a child process. All processes are descendants of the first system process, which is systemd 

=> ps command is used for listing current processes :
 -> UID -> determines process privileges
 -> PID -> process identification id
 -> cpu and real time already expended
 -> how much memory the process has allocated in various locations
 -> location of process stdout, known as controlling terminal
 -> the current process state

 => ps aux
 => ps lax
 => ps -ef

 ps with no options selects all processes with the same effective user id as current user and associated with the same terminal where ps was invoked.
 -> processes in brackets are scheduled kernel threads
 -> zombies show up in a ps listing as exiting or defunct(zombie is a state of a process wherein it gives up all its resources except the PID)

 => top command -> repetitive update process display
  ps can display in tree format to view parent/child relationships

 Job control is a command shell feature allowing a single shell instance to run and manage multiple commands. Without job control, a parent shell forks a child process to run a command sleeping until the child process exits. When the shell prompt redisplays, the parent shell has returned. With job control, commands can be selectively suspended, resumed and run asynchronously, allowing the shell to return for additional commands while child processes run. 
 
 A foreground process is a command running in a terminal window. The terminal's device id(tty) is the process's controlling terminal. Foreground processes receive keyboard generated input and signals and are allowed to read from or write to the terminal(stdin or stdout).

 A process session is created when a terminal or console first opens(eg. at login or by invoking a new terminal instance). All processes(first command shell, its children and pipelines ) initiated from that terminal share the same session id. Within a session, only 1 process can be in the foreground at a time.

 A background process is started without a controlling terminal because it has no need for terminal interaction. In a ps listing, such processes (eg. service daemons and kernel process threads) display a ? in the tty column. Background processes which (improperly)attempt to read from or write to the terminal may be suspended.

Any command can be started in the background by appending an & to the command line. The bash shell displays a job number(unique to the session) and the PID of the new child process. The command shell does not wait for the child process and redisplays the shell prompt.
An & will background only the last command in a pipeline, unless the command set is surrounded with parentheses. The PID returned is from the pipeline's last process. All processes in the pipeline are now members of the same job.

=> jobs -> shows jobs per session
=> sleep 10000 & -> puts command shell in sleep mode

=> fg %1 -> Background jobs can reconnect to the controlling terminal by being brought to the foreground using the fg command with the job ID (%job number)
To resend to the background, or to send any command in which the trailing ampersand was not originally included, send keyboard generated suspend request (ctrl+z) to the process.
=> bg %1 -> restarts the background process.

A signal is a software interrupt delivered to a process. Signals report events to an executing program. Events that generate a signal can be an error, external event, or by explicit request. 

Each signal has a default action :
term - causes a program to terminate at once
core - causes a program to save a memory image(core dump) then terminate
stop - causes a program to stop executing(suspend) and waiting to continue(resume)

ctrl+z -> suspend
ctrl+c -> kill
ctrl+\ -> core dump 

To signal a background process or processes in a different session requires a signal-sending command.
Users may kill their own processes, but root privilege is required to kill processes owned by others.
1 SIGHUP,2 SIGINT,3 SIGQUIT,4 SIGILL,5 SIGTRAP,6 SIGABRT,7 SIGBUS,8 SIGFPE,9 SIGKILL,10 SIGUSR1,11 SIGSEGV,12 SIGUSR2,13 SIGPIPE,14 SIGALRM,15 SIGTERM,16 SIGSTKFLT,17 SIGCHLD,18 SIGCONT,19 SIGSTOP,20 SIGTSTP

=> kill PID -> kill command can be used for sending any signal, not just those for terminating programs
=> kill -signal PID

=> killall command_pattern -> send a signal to 1 or more processes matching selection criteria, such as a command name, processes owned by a specific user or all system-wide processes
=> killall -signal command_pattern
=> killall -signal -u username command_pattern

=> pkill command -> like killall can signal multiple processes, uses advanced selection criteria which can include combinations of :
	-> command -> processes with a pattern matched command name
	-> UID -> processes owned by a linux user account, effective or real
	-> GID -> processes owned by a linux group account, effective or real
	-> parent -> child processes of a specific parent process
	-> terminal -> processes running on a specific controlling terminal
=> pkill -signal command_pattern
=> pkill -G GID command_pattern
=> pkill -P PPID command pattern
=> pkill -t terminal_name -U UID command_pattern

=> w command views users currently logged into the system and their cumulative activities. use the tty and from columns to determine the user's location
All users have a controlling terminal, listed as pts/N while working in a graphical environment window or ttyN on a system console.
Remote users display their connecting system name in the FROM column when using the -f option.
For each session, CPU resources consumed by current jobs, included background tasks and children, are in the JCPU column. Current foreground process CPU consumption is in the PCPU column.

When situations occur in which users cannot be contacted or have unresponsive sessions, runaway resource consumption, or improper system access. their sessions may need to be administratively terminated using signals.

Although SIGTERM is the default signal, SIGKILL is a commonly misused administrative favourite. Since the SIGKILL signal cannot be handled or ignored, it is always fatal. However it forces termination without allowing the killed process to run self-cleanup routines. It is recommended to send SIGTERM first, then retry with SIGKILL only if a process fails to respond.

=> pkill -SIGKILL -u username -> kills all of a user's processes and login shells.
=> pkill -SIGKILL -t tty3 -> causes the terminal to close abruptly
=> pgrep -l -u username -> view all of a user's processes
=> pstree command -> view a process tree for the system or a single user
killing a parent process will kill all its child processes
=> pstree -p username

=> kill -SIGSTOP %number -> suspend a process using signal
=> kill -SIGTERM %number -> kill a process using signal
=> kill -SIGCONT %number -> resume a process using signal

The linux kernel calculates a load average metric as an exponential moving average of the load number, a cumulative CPU count of active system resource requests.
-> Active requests are counted from per-CPU queues for running threads and threads waiting for I/O, as the kernel tracks process resource activity and corresponding process state changes
-> Load number is a calculation routine run every 5 seconds by default, which accumulates and averages the active requests into a single number for all CPUs
-> Exponential moving average is a mathematical formula to smooth out trending data highs and lows, increase current activity significance, and decrease aging data quality 
-> Load average is the load number calculation routine result. Collectively, it refers to the 3 displayed values of system activity data averaged for the last 1, 5 and 15 minutes. It represents the percieved system load over a time period. Linux implements the load average calculation as a representation of expected service wait times, not only for CPU but also for disk and network I/O

Linux counts not only processes, but threads individually as separate tasks. 
Linux counts each physical CPU core and microprocessor hyperthread as separate execution units, logically represented and referred to as individual CPUs. Each CPU has independant request queues.
/proc/cpuinfo for the kernel representation of system CPUs

=> top, uptime, w and gnome-system-monitor display load average values. 
Divide the displayed load average values by the number of logical CPUs in the system. A value below 1 indicates satisfactory resource utilization and minimal wait times. A value above 1 indicates resource saturation and some amount of service waiting times

An idle CPU queue has a load number of 0. Each ready and waiting thread adds a count of 1. With a total queue count of 1, the resource is in use, but no requests spend time waiting. Additional requests increment the count, but since many requests can be processed within the time period, resource utilization increases, but not wait times.

Unlike the static ps output, top continuously refreshes at a configurable interval and provides capabilites for column reordering, sorting and highlighting. User configurations can be saved and made persistent.
 -> PID
 -> UID
 -> VIRT -> virtual memory is all memory the process is using, including the resident set, shared libraries, and any mapped or swapped memory pages.
 -> RED -> resident memory is the physical memory used by the process, including any resident shared objects.

->Process state displays as :
 -> D -> uniterruptible sleeping
 -> R -> Running or Runnable
 -> S -> Sleeping
 -> T -> Stopped or Traced
 -> Z -> Zombie

-> CPU Time is the total processing time since the process has started. May be toggled to include cumulative time of all previous children.

-> The process command name  

The default configuration file is .toprc in the current user's home directory.

Press P to sort by cpu utilization
Press B to toggle bole use on 
Press M to save the configuration
Press q to quit current display

System startup and server processes are managed by systemd System and Service Manager. This program provides a method for activating system resources, server daemons, and other processes both at boot time and on a running system.

Daemons are processes that wait or run in the background performing various tasks. Generally daemons start automatically at boot time and continue to run until shutdown or until they are manually stopped. By convention, the names of many daemon programs end in the letter d.

To listen for connections, a daemon uses a socket. This is the primary communication channel with local or remote clients. Sockets may be created by daemons or may be separated from the daemon and be created by another process, such as systemd. The socket is passed to the daemon when a connection is established by the client.

A service often refers to 1 or more daemons, but starting or stopping a service may instead make a 1 time change to the state of the system, which does not involve leaving a daemon process running afterward(called oneshot).

For many years process id 1 of Linux and Unix system has been the init process. This process was responsible for activating other services on the system and is the origin of the term init system. Frequently used daemons were started on systems at boot time with System V and LSB init scripts. Less frequently used daemons were started on demand by another service, such as initd or xinetd, which listens for client connections. These systems have several limitations, which are addressed by systemd.

Process ID 1 in RHEL7 is systemd, the new init system. Few of the new features provided by systemd include:
 -> parallelization capabilites, which increase boot speed of the system
 -> on demand starting of daemons without requiring a separate service
 -> automatic service dependency management, which can prevent long timeouts, such as by not starting a network service when the network is not available
 -> a method of tracking related processes together by using Linux Control Groups.

 The systemctl command is used to manage different types of systemd objects, called units. 
 => systemctl -t help -> shows a list of available unit types 

 Some common unit types are listed :
 	->Service units have a .service extension and represent system services. This type of unit is used to start frequently accesses daemons, such as web server.
 	-> Socket units have a .socket extension and represent inter-process communication sockets. Control of the socket will be passed to a daemon or newly started service when a client connection is made. Socket units are used to delay the start of a service at boot time and to start less frequently used services on demand. These are similar in principle to services which use the xinetd superserver to start on demand.
 	-> Path units have a .path extension and are used to delay the activation of a service until a specific file system change occurs. This is commonly used for services which use spool directories, such as printing system. 

 =>	systemctl status name.type -> view the status of a service. for eg. systemctl status sshd.service. -l option will show the full details. If the unit type is not provided, systemctl will show the status of a service unit, if 1 exists.
 status can also be used to determine if a particular unit is active and show if the unit is enabled to start at boot time.
 => systemctl is-active sshd -> if system is active 
 => systemctl is-enabled sshd -> if system is enabled 

 enabled/disabled -> will/will not be started at boot time
 static -> can not be enabled, but may be started by an enabled unit automatically

-> list the active state of all loaded units
systemctl list-unitts --type=service
systemctl list-units --type=service --all -> all option adds inactive results

=> systemctl list-unit-files --type=service -> view the enabled and disabled settings for all units
=> systemctl --failed --type=service -> view only failed services
refer http://docs.redhat.com/ for additional information
=> systemctl reload sshd.service -> reload configuration for sshd service
=> systemctl restart sshd.service -> restart sshd service
=> systemctl stop sshd.service -> stop sshd service

Services may be started as dependencies of other services. If a socket unit is enabled and the service unit with the same name is not, the service will automatically be started when a request is made on the network socket.

=> systemctl list-dependencies UNIT command can be used to print out a tree of what other units must be started if the specified unit is started. 
To prevent an administrator from accidentally starting a service, that service may be masked. Masking will create a link in the configuration directories so that if a service is started, nothing will happen.

=> systemctl mask network -> mask a service
=> systemctl unmask network -> unmask a service

A disabled service will not be started automatically at boot or by other unit files, but can be started manually. A masked service cannot be started manually or automatically.

Services are started at boot time when links are created in the appropriate systemd configuration directories. These links are created and removed with systemctl commands.

The OpenSSH Secure Shell is used to securely run a shell on a remote system. The ssh can also be used to run an individual command on a remote system.

=> ssh remotehost -> create a remote interactive shell as the current user
=> ssh remoteuser@remotehost -> connect to a remote shell as a different user(remoteuser) on a selected host(remotehost)
=> ssh remoteuser@remotehost hostname -> execute the command hostname on the remote host

SSH secures communication through public key encryption. When a SSH client connects to an SSH server, before the client logs in, the server sends it a copy of its public key. The first time a user uses SSH to connect to a particular server, the ssh command stores the server's public key in the user's ~/.ssh/known_hosts file. Every time the user connects after that, the client makes sure it gets the same public key from the server by comparing the server's entry in the ~/.ssh/known_hosts file to the public key the server sent. If the keys do not match, the client assumes that the network traffic is being hijacked or that the server has been compromised and breaks the connection.

Host IDs are stored in ~/.ssh/known_hosts
Host Keys are stored in /etc/ssh/ssh_host_key* on the ssh server
see ssh-copy-id(1)

SSH key-based authentication 
 -> Users can authenticate ssh logins without a password by using public key authentication. ssh allows users to authenticate using a private-public key scheme. This means that 2 keys are generated, a private key and a public key. The private key file is used as the authentication credential, and like a password must be kept secret and secure. The public key is copied to systems the user wants to log into and is used to verify the private key. 

=> ssh-keygen -> generate private-public key pair ~/.ssh/id_rsa, ~/.ssh/id_rsa.pub
 In the event the private key is stolen, it is very difficult for someone other than the issuer to use it when protected with a passphrase.
 However passphrase has to be entered whenever the key is used, making the authentication process no longer password less. This can be avoided using ssh-agent, which can be given your passphrase once at the start of the session(using ssh-add), so it can provide the passphrase as needed while you stay logged in. Permissions should be 600 on the private key and 644 on public key. Before key based authentication can be used, the public key needs to be copied on the destination system. This can be done with ssh-copy-id.
=> ssh-copy-id root@desktopY -> copies the ~/.ssh/id_rsa.pub file by default.
=> ssh serverX 'hostname' -> display hostname of the serverX machine without the need to enter a password.

Various aspects of the OpenSSH server can be modified in the configuration file /etc/ssh/sshd_config

It is advisable to prohibit the root user from directly logging into the system with ssh 
 -> root user has unrestricted privileges
 -> the username root exists on every Linux system by default, so a potential attacker only has to guess the password, instead of a valid username and password combination

The sshd service has to be restarted to put the changes into effect. 
=> systemctl restart sshd

to allow only key-based ssh login as root with 
 -> PermitRootLogin without-password

to turn on password authentication 
 -> PasswordAuthentication yes

key-based logins have various adantages :
 -> SSH keys are longer than an average password, which adds security.
 -> less effort to initiate remote shell access after the initial setup.

Any changes to the file will take effect once sshd service is restarted

=> lab ssh setup

Processes and the operating system kernel need to be able to record a log of events that happen. These logs can be useful for auditing the system and troubleshooting problems. By convention, the /var/log directory is where these logs are persistently stored.
A standard login system based on the syslog protocol is built into RHEL. In RHEL7, syslog messages are handled by 2 services, systemd-journald and rsyslog. 

The systemd-journald daemon provides an improved log management service that collects messages from the kernel, the early stages of the boot process, standard output and error of daemons as they start up and run and syslog. It writes these messages to a structured journal of events, that by default does not persist between reboots. This allows syslog messages and events which are missed by syslog to be collected in 1 central database. The syslog messages are also forwarded by systemd-journald to rsyslog for further processing.

The rsyslog service then sorts the syslog messages by type and priority, and writes them to persistent files in the /var/log directory.

The /var/log directory holds various system and service-specific log files maintained by rsyslog.
 => /var/log/messages -> Most syslog messages are logged here. The exceptions are messages related to authentication and email processing, that periodically run jobs, and those which are purely debugging related. 
 => /var/log/secure -> the log file for security and authentication related messages and errors
 => /var/log/maillog -> the log file for mail server related messages
 => /var/log/cron -> the log file related to periodically executed tasks
 => /var/log/boot.log -> messages related to system startup are logged here

 Many programs use the syslog protocol to log events to the system. Each log message is categorized by facility(type of message) and a priority(the severity of the message). The facilities which are available are documented by the rsyslog.conf man page

 Priorities in syslog files are :
 0 emerg -> system is unusable
 1 alert -> action must be taken immediately 
 2 crit -> critical condition
 3 err -> non-critical error condition
 4 warning -> warning condition
 5 notice -> normal but significant event
 6 info -> informational event
 7 debug -> debugging-level message

The rsyslog service uses the facility and priority of log messages to determine how to handle them. This is configured in the file /etc/rsyslog.conf and by *.conf files in /etc/rsyslog.d. Programs and administrators can change rsyslogd configuration in a way that will not be overwritten by updates to rsyslog by putting customized files with a .conf suffix in the /etc/rsyslog.d directory.

The RULES section of the /etc/rsyslog.conf contains directives that define where log messages are saved. * stands for all facilites or all severities.

log files are maintained by the rsyslog service and /var/log directory contains a variety of log files specific to certain services. 

A message handled by rsyslog can appear in multiple different log files. To prevent that, the severity field can be set to none, which means that none of the messages directed to this facility are added to the specified log file. 

Logs are rotated by the logrotate utility to keep them from filling up the file system containing /var/log. When a log file is rotated, it is renamed with an extension indicating the date on which it was rotated. Once the old log file is rotated, a new log file is created and the service that writes to it is notified.

After a certain number of rotations, typically after 4 weeks, the old log file is discarded to free disk space. A cron job runs the logrotate program daily to see if any logs need to be rotated. Most log files are rotated weekly, but logrotate rotates some faster, or slower, or when they reach a certain size.

Log file format:
1. The timestamp when the log entry was recorded.
2. The host from which the log message was sent.
3. The program or process that sent the log message.
4. The actual message sent.

=> logger -p local7.notice "Log entry created on serverx"
The logger command can send messages to the rsyslog service

The systemd journal stores logging data in a structured, indexed binary file. This data included extra information about the log event. 
The systemd journal is stored in /run/log by default, and its contents are cleared after a reboot. This setting can be changed by the system administrator.

=> journalctl
The journalctl command shows the full system journal, starting with the oldest log entry when run as root user.
=> journalctl -n 10 -> shows the last 10 log entries.
=> journalctl -p err -> takes either the name or the number of the known priority levels and shows the given levels and all higher level entries.
=> journalctl -f -> outputs the last 10 lines of the journal and continues to output new journal entries.
=> journalctl --since today -> output all journal entries that got recorded today 
=> journalctl --since "2014-02-10 20:30:00" --until "2014-02-13 12:00:00" -> output all journal entries between given time frame
=> journalctl -o verbose 
=> journalctl _SYSTEMD_UNIT=sshd.service _PID=1182 
	-> _COMM -> name of command
	-> _EXE -> path to the executable for the process
	-> _UID -> UID of the user running the process
	-> _SYSTEMD_UNIT -> the systemd unit that started the process

By default the systemd-journal is kept in /run/log/journal, which means it is cleared when the system reboots. If the directory /var/log/journal exists, the journal will log to that directory instead. The advantage of this is that the historic data will be available immediately at boot. The journal has a built in log rotation mechanism that will trigger monthly. In addition the journal will not be allowed to get larger than 10% of the file system it is on, or leave less than 15% of the file system free. These values can be tuned inside /etc/systemd/journald.conf, and the current limits on the size of the journal are logged when the systemd-journal process starts. 

=> chown root:systemd-journal /var/log/journal
=> chmod 2755 /var/log/journal 
=> killall -USR1 systemd-journald
=> journalctl -b -> shows log messages since the last boot of the system
=> journalctl -b -1 -> limits the output to the previous boot

The Network Time Protocol(NTP) is a standard way for machines to provide and obtain correct time information on the Internet. A machine may get accurate time information from public NTP services on the internet such as the NTP Pool Project. 

=> timedatectl -> shows an overview of the current time-related system settings, including current time, time zone and NTP synchronization settings of the system. 

=> timedatectl list-timezones -> database with known time zones can be listed
Time zone names are based on the public tz timezone database maintained by IANA. Time zones are named based on continents or oceans, then typically but not always the largest city within the time zone region. 
=> tzselect -> useful for identifying correct zoneinfo time zone names. It interactively prompts the user with questions about the system's location, and outputs the name of the correct time zone. It does not make any changes to the time zone setting of the system.

=> timedatectl set-timezone America/Phoenix -> set timezone to America/Phoenix
=> timedatectl set-time 09:00:00 -> set time to 9:00 am
=> timedatectl set-ntp true -> enables ntp synchronization for automatic time adjustment

The chronyd service keeps the usually-inaccurate local hardware clock(RTC) on track by synchronizing it to the configured NTP servers, or if no network connectivity is available, to the calculated RTC clock drift which is recorded in the driftfile specified in the /etc/chrony.conf configuration file.

By default, chronyd uses servers from the NTP Pool Project for the time synchronization and does not need additional configuration. It may be useful to change the NTP servers when the machine in question is on an isolated network.

The quality of an NTP time source is determined by the stratum value reported by the time source. The stratum determines the number of hops the machine is away from a high-performance reference clock. The reference clock is a stratum 0 time source. An NTP server directly attached to it is a stratum 1, while a machine synchronizing time from the NTP server is a stratum 2 time source.

There are 2 categories of time sources that can be configured in the /etc/chrony.conf configuration file, server and peer. The server is 1 stratum above the local NTP server, and the peer is at the same stratum level. More than 1 server and more than 1 peer can be specified, 1 per line.

Use the iburst option to finetune. 
=> systemctl restart chronyd -> Restart chronyd service after making configuration changes.  

The chronyc command acts as a client to the chronyd service. 
=> chronyc sources -v -> verify NTP server was used to synchronize the clock 

Steps to set up correct time zone and adjust system clocks:
	-> identify appropriate time zone -> timedatectl list-timezones
	-> verify the clock was synchronized against the newly specified NTP source with the command -> chronyc sources
	-> point chronyd to a new time source by adjusting /etc/chrony.conf
	-> turn on NTP synchronization 
	-> review current settings with timedatectl 
	-> set the correct time zone -> timedatectl set-timezone
	-> restart chronyd service -> systemctl restart chronyd

When a packet is sent across a network, the combination of the service port and IP address forms a socket. 

An IPv4 address is a 32 bit number, normally expressed in decimal as 4 octets ranging in value from 0 to 255, separated by .
The address is divided into 2 parts, the network part and the host part. All hosts on the same subnet, which can talk directly to each other directly without a router, have the same network part , the network part identifies the subnet. No 2 hosts on the same subnet can have the same host part.

To know which part of an IPv4 address is the network part and which is the host part, an administrator must know the netmask which is assigned to the subnet. The more bits that are available for the host part, the more hosts can be on the subnet.

The lowest possible address on the subnet is sometimes called the network address. The highest possible address on a subnet is used for broadcast messages in IPv4, and is called the broadcast address.

Network address for 172.16.181.23/19
Host address -> 10101100.10101000.10110101.00010111
Network address -> 10101100.10101000.10100000.00000000
Broadcast address -> 10101100.10101000.10111111.11111111

127.0.0.1 -> points to the local system(localhost) and the network 127.0.0.0/8 belongs to the local system, so that it can talk to itself using network protocols.

Each host has a routing table, which tells it how to route traffic for particular networks. 




























































































































































